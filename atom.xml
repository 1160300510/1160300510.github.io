<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joker</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-27T09:38:15.904Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Joker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode每日一题-缺失的第一个正数</title>
    <link href="http://yoursite.com/2020/06/27/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <id>http://yoursite.com/2020/06/27/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</id>
    <published>2020-06-27T08:35:53.000Z</published>
    <updated>2020-06-27T09:38:15.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><img src="/2020/06/27/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/image1.png" alt="image1"></p><p>这题只想出来了时间复杂度$O(N)$，空间复杂度$O(N)$的做法，思路就是把数组所有的数都存入哈希表，随后从1 开始依次枚举正整数，并判断其是否在哈希表中。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = nums.length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            set.add(nums[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!set.contains(i))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>但是题目要求空间复杂度为$O(1)$，即不能使用额外的存储空间，但没有限制不能对原数组进行修改，因此可以利用原数组来满足空间复杂度要求。</p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p>对于一个长度为$N$的数组，其中没有出现的最小正整数只能在$[1,N+1]$中。这是因为如果$[1,N]$都出现了，那么答案一定是$N+1$，否则答案就是$[1,N]$中没有出现的最小正整数。在上面的方法中，我们将所有在范围内的数放入哈希表，可以得到最终的答案。但是这里不能申请额外空间，而给定的数组恰好长度为$N$，因此可以利用给定的数组设计成类似哈希表的东西。</p><p>我们可以遍历数组，对于遍历到的数$x$，如果不在$[1,N]$范围内就忽略。否则，就将数组第$x-1$个位置打上标记，表明该数出现过（数组下标从0开始，因此数组下标$x-1$代表的数为$x$）。在遍历结束之后，如果所有的位置都被打上标记，那么答案就是$N+1$，否则答案是最小的没有打上标记的位置加1。</p><p>由于数组中可能出现负数，因此需要先遍历数组，将负数变为无关紧要的数，例如$N+1$，同时这里标记可以使用负号。算法流程如下：</p><ul><li>先将数组中所有小于等于0的数变为$N+1$。</li><li>遍历数组中的每一个数$x$，如果对应位置$|x|-1$已经打上标记（使用绝对值是因为$x$如果已经标记过那么它现在为负数），那么就跳过，否则就打上标记。</li><li>在遍历完成后，如果数组每一个位置都为负数，那么答案为$N+1$，否则为第一个正数出现的位置加1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = nums.length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                nums[i] = len+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> num = Math.abs(nums[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(num&lt;=len &amp;&amp; num&gt;=<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                nums[num-<span class="number">1</span>] = -Math.abs(nums[num-<span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="方法二：置换"><a href="#方法二：置换" class="headerlink" title="方法二：置换"></a>方法二：置换</h2><p>基本思想就是将数组恢复成下面的形式：</p><blockquote><p>如果数组中包含$x \in [1,N]$，那么将数组的第$x-1$个位置的元素恢复为$x$。</p></blockquote><p>在恢复之后，数组的形式应该为$[1,2,…,N]$的形式，但其中有若干个位置错误，每一个错误的位置就代表了一个缺失的正数。我们可以对数组进行一次遍历，对于遍历到的数$x=nums[i]$，如果$x \in [1,N]$，那么$nums[i]$和$nums[x-1]$就交换位置，新交换得到的$nums[i]$可能仍在$[1,N]$范围内，此时继续交换，直到$x \notin [1,N]$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = nums.length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//进入置换,其中nums[nums[i]-1] != nums[i]防止陷入死循环</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span>(nums[i]&gt;=<span class="number">1</span> &amp;&amp; nums[i]&lt;=len &amp;&amp; nums[nums[i]-<span class="number">1</span>] != nums[i])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> temp = nums[nums[i]-<span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                nums[i] = temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缺失的第一个正数&quot;&gt;&lt;a href=&quot;#缺失的第一个正数&quot; class=&quot;headerlink&quot; title=&quot;缺失的第一个正数&quot;&gt;&lt;/a&gt;缺失的第一个正数&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/06/27/leetcode%E6%AF%8F%E6%97%
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
      <category term="每日一题" scheme="http://yoursite.com/categories/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题-移除重复节点</title>
    <link href="http://yoursite.com/2020/06/26/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/06/26/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</id>
    <published>2020-06-26T06:18:13.000Z</published>
    <updated>2020-06-26T07:02:18.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移除重复节点"><a href="#移除重复节点" class="headerlink" title="移除重复节点"></a>移除重复节点</h1><p><img src="/2020/06/26/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/image1.png" alt="image1"></p><p>链表结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * public class ListNode &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *     int val;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *     ListNode next;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr></table></figure><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p>对给定的链表进行一次遍历，并用一个哈希集合(HashSet)来存储所有出现过的节点。在遍历过程中，如果节点的值已经在集合中出现过，就移除该节点。这里有一个需要注意的地方，在移除节点的过程中，我们本质上是把该节点的前驱节点和后继节点相连，但根据链表节点的结构来看，我们无法得到节点的前驱节点，因此我们把枚举对象由当前节点改为前驱节点<code>u</code>，那么当前节点就为<code>u.next</code>，后继节点就为<code>u.next.next</code>，ac代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        ListNode node = head;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        set.add(node.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//枚举前驱节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//移除重复节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(set.contains(node.next.val))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(node.next.next == <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                    node.next = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    node.next = node.next.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">              <span class="comment">//向集合中添加未出现过的节点，并向后移动前驱节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                set.add(node.next.val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                node = node.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，其中$N$是给定链表中节点的数目。</li><li>空间复杂度：$O(N)$，在最坏情况下，给定链表中每个节点都不相同，哈希表中需要存储所有的$N$个值。</li></ul><h2 id="方法二：双重循环"><a href="#方法二：双重循环" class="headerlink" title="方法二：双重循环"></a>方法二：双重循环</h2><p>题目有个进阶的要求，即不允许使用临时缓冲区，那么只能用时间换空间。具体就是第一重循环枚举待保留的节点，第二重循环就从该节点开始，到链表的末尾结束，将所有与保留节点相同的节点全部移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        ListNode ob = head;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (ob != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            ListNode oc = ob;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> (oc.next != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (oc.next.val == ob.val) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    oc.next = oc.next.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    oc = oc.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            ob = ob.next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N^2)$，其中$N$是给定链表中节点的数目。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移除重复节点&quot;&gt;&lt;a href=&quot;#移除重复节点&quot; class=&quot;headerlink&quot; title=&quot;移除重复节点&quot;&gt;&lt;/a&gt;移除重复节点&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/06/26/leetcode%E6%AF%8F%E6%97%A5%E4%B8
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
      <category term="每日一题" scheme="http://yoursite.com/categories/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mining Test Execution History to Support Test Selection, Prioritization, and Guide Bisection</title>
    <link href="http://yoursite.com/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/"/>
    <id>http://yoursite.com/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/</id>
    <published>2019-12-12T07:02:26.000Z</published>
    <updated>2019-12-12T08:44:26.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection"><a href="#Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection" class="headerlink" title="Mining Test Execution History to Support Test Selection, Prioritization, and Guide Bisection"></a>Mining Test Execution History to Support Test Selection, Prioritization, and Guide Bisection</h1><p>相关文章：<a href="http://users.encs.concordia.ca/~shang/pubs/Armin_FSE_2019.pdf" target="_blank" rel="noopener">Bisecting Commits and Modeling Commit Risk during Testing</a></p><p><img src="/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/image1.png" alt="image1"></p><p>背景：</p><ul><li>Software testing is expensive</li><li>Too many test need to be run</li></ul><h2 id="RQ1-What-is-the-most-cost-effective-BatchSize-for-the-number-of-culprits-discovered-during-testing"><a href="#RQ1-What-is-the-most-cost-effective-BatchSize-for-the-number-of-culprits-discovered-during-testing" class="headerlink" title="RQ1: What is the most cost-effective BatchSize for the number of culprits discovered during testing?"></a>RQ1: What is the most cost-effective BatchSize for the number of culprits discovered during testing?</h2><p>Bisect介绍：</p><p><img src="/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/image2.png" alt="image2"></p><p>在这种情况下，需要跑五次测试，比单独挨个测试还要多。</p><p>Conclusion: The higher the CulpritRate the smaller the most costeffective BatchSize.</p><p><img src="/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/image3.png" alt="image3"></p><h2 id="RQ2-What-is-the-most-cost-effective-BatchSize-when-some-bisections-are-done-as-a-result-of-flaky-failures"><a href="#RQ2-What-is-the-most-cost-effective-BatchSize-when-some-bisections-are-done-as-a-result-of-flaky-failures" class="headerlink" title="RQ2: What is the most cost-effective BatchSize when some bisections are done as a result of flaky failures?"></a>RQ2: What is the most cost-effective BatchSize when some bisections are done as a result of flaky failures?</h2><p>The higher the FlakeRate the smaller the BatchSize and smaller the savings in executions.</p><p><img src="/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/image4.png" alt="image4"></p><p>TestTopK思想：</p><p><img src="/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/image5.png" alt="image5"></p><p>关键在于预测模型。之前对于commit-level bug prediction的研究可以帮助。Test history证明对于预测模型是有效的。</p><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6341763" target="_blank" rel="noopener">A Large-Scale Empirical Study of Just-in-Time Quality Assurance</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.702.9819&rep=rep1&type=pdf" target="_blank" rel="noopener">Commit Guru: Analytics and Risk Prediction of Software Commits</a></p><p><a href="https://users.encs.concordia.ca/~pcr/paper/Zhu2018ICSME.pdf" target="_blank" rel="noopener">Test Re-prioritization in Continuous Testing Environments</a></p><p>An example of calculating the culprit score</p><p><img src="/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/image6.png" alt="image6"></p><ul><li>Probability of a file A change cooccurring with Test 1 fail is 3/8=0.375</li><li>Normalized probobility of file A change and Test 1 fail is 0.375*(20/30)</li><li>Culprit score of commit 101 = 0.375<em>(20/30) + 0.25</em>(10/30)=0.33</li></ul><p>结果：</p><p><img src="/2019/12/12/Mining-Test-Execution-History-to-Support-Test-Selection-Prioritization-and-Guide-Bisection/image7.png" alt="image7"></p>]]></content>
    
    <summary type="html">
    
      对Mining Test Execution History to Support Test Selection, Prioritization, and Guide Bisection报告的记录与总结
    
    </summary>
    
    
      <category term="NASAC2019" scheme="http://yoursite.com/categories/NASAC2019/"/>
    
      <category term="软件仓库挖掘论坛" scheme="http://yoursite.com/categories/NASAC2019/%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93%E6%8C%96%E6%8E%98%E8%AE%BA%E5%9D%9B/"/>
    
    
      <category term="NASAC2019" scheme="http://yoursite.com/tags/NASAC2019/"/>
    
  </entry>
  
  <entry>
    <title>Mining Software Data for Better Software Quality</title>
    <link href="http://yoursite.com/2019/12/11/Mining-Software-Data-for-Better-Software-Quality/"/>
    <id>http://yoursite.com/2019/12/11/Mining-Software-Data-for-Better-Software-Quality/</id>
    <published>2019-12-11T13:57:55.000Z</published>
    <updated>2020-06-26T06:19:56.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mining-Software-Data-for-Better-Software-Quality"><a href="#Mining-Software-Data-for-Better-Software-Quality" class="headerlink" title="Mining Software Data for Better Software Quality"></a>Mining Software Data for Better Software Quality</h1><h2 id="Automated-bug-fixing-from-Bug-Reports"><a href="#Automated-bug-fixing-from-Bug-Reports" class="headerlink" title="Automated bug fixing from Bug Reports"></a>Automated bug fixing from Bug Reports</h2><h3 id="Define-Fix-Pattern"><a href="#Define-Fix-Pattern" class="headerlink" title="Define Fix Pattern"></a>Define Fix Pattern</h3><p><a href="https://jinqiuyang.github.io/papers/r2fix-icst13.pdf" target="_blank" rel="noopener">R2Fix: Automatically Generating Bug Fixes from Bug Reports</a></p><p><img src="/2019/12/11/Mining-Software-Data-for-Better-Software-Quality/image1.png" alt="image1"></p><p>报告人手动研究了开发人员如何修复三种主要的和重要的bug类型，例如86.6%的缓冲区溢出可以通过以下方式解决：</p><ul><li>Allocate a longer buffer</li><li>Assign fewer bytes to a buffer</li><li>Modify the bound check condition</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">E.g.,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- <span class="built_in">strcpy</span>(&lt;<span class="built_in">buffer</span>&gt;,&lt;expression&gt;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">+ <span class="built_in">strcpy</span>(&lt;<span class="built_in">buffer</span>&gt;,&lt;exprsssion&gt;,<span class="keyword">sizeof</span>(&lt;<span class="built_in">buffer</span>&gt;);</span></pre></td></tr></table></figure><h3 id="Using-classification-to-decide-the-bug-type"><a href="#Using-classification-to-decide-the-bug-type" class="headerlink" title="Using classification to decide the bug type"></a>Using classification to decide the bug type</h3><pre class="mermaid">graph LR;    A[Bug reports E.g.Bugzilla]--> |Bag-of-words model| B[Real bug?]    B[Real bug?]--> |Yes| C[Root Causes?]    B[Real bug?]--> |No| D[ ]    C[Root Causes?]-->E[Buffer overflow]    C[Root Causes?]-->F[Null pointer]    C[Root Causes?]-->G[Memory leak]    C[Root Causes?]-->H[Not one of the three bug types]</pre><p><strong>90.3%</strong> of  the classified ‘buffer overflow’ bug reports are <strong>true</strong> buffer overflows.</p><h2 id="Extracting-Web-API-Specifications-from-Documentation"><a href="#Extracting-Web-API-Specifications-from-Documentation" class="headerlink" title="Extracting Web API Specifications from Documentation"></a>Extracting Web API Specifications from Documentation</h2><p><a href="https://ece.uwaterloo.ca/~lintan/publications/webapi-msr18.pdf" target="_blank" rel="noopener">Towards Extracting Web API Specifications from Documentation</a></p><p><img src="/2019/12/11/Mining-Software-Data-for-Better-Software-Quality/image2.png" alt="image2"></p><p>Challenges faced by consumers:</p><ul><li>Finding “the right” APIs</li><li>Correctly using APIs</li><li>Detecting and reacting to API changes</li></ul><p>报告人提出了一个自动提取specification的方法</p><p><img src="/2019/12/11/Mining-Software-Data-for-Better-Software-Quality/image3.png" alt="image3"></p><p>提取结果与API Harmony、APIs.guru上的相比</p><ul><li>Our approach achieves reasonably precise results</li><li>Documentation may contain errors</li><li>There exist many inconsistencies between documentation and crawled specifications, e.g., due to API updates.</li></ul><h2 id="Studing-and-improving-testing-practices"><a href="#Studing-and-improving-testing-practices" class="headerlink" title="Studing and improving testing practices"></a>Studing and improving testing practices</h2><p><a href="https://jinqiuyang.github.io/papers/ase19.pdf" target="_blank" rel="noopener">A Study of Oracle Approximations in Testing Deep Learning Libraries</a></p><p><img src="/2019/12/11/Mining-Software-Data-for-Better-Software-Quality/image4.png" alt="image4"></p><ul><li>There exists a significant portion of oracle approximations in DL libraries</li><li>Developers constantly modify oracle approximations for evolution needs, esp. modifying tolerances to avoid flaky tests and manage variabilities</li></ul>]]></content>
    
    <summary type="html">
    
      对Mining Software Data for Better Software Quality报告的记录与总结
    
    </summary>
    
    
      <category term="NASAC2019" scheme="http://yoursite.com/categories/NASAC2019/"/>
    
      <category term="软件仓库挖掘论坛" scheme="http://yoursite.com/categories/NASAC2019/%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93%E6%8C%96%E6%8E%98%E8%AE%BA%E5%9D%9B/"/>
    
    
      <category term="NASAC2019" scheme="http://yoursite.com/tags/NASAC2019/"/>
    
  </entry>
  
  <entry>
    <title>Mining Software Repositories in the age of AI</title>
    <link href="http://yoursite.com/2019/12/11/Mining-Software-Repositories-in-the-age-of-AI/"/>
    <id>http://yoursite.com/2019/12/11/Mining-Software-Repositories-in-the-age-of-AI/</id>
    <published>2019-12-11T07:52:40.000Z</published>
    <updated>2019-12-11T14:56:59.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mining-Software-Repositories-in-the-age-of-AI"><a href="#Mining-Software-Repositories-in-the-age-of-AI" class="headerlink" title="Mining Software Repositories in the age of AI"></a>Mining Software Repositories in the age of AI</h1><p>此文在我个人理解之上总结的，同时也并不是完整的报告内容，只是其中一部分，如有错误，恳请指正。</p><h2 id="概念简介"><a href="#概念简介" class="headerlink" title="概念简介"></a>概念简介</h2><ul><li><p>Code Smell</p><p>Code Smell中文译名一般为“代码异味”，或“代码味道”，它是提示代码中某个地方存在错误的一个暗示，开发人员可以通过这种smell（异味）在代码中追捕到问题。</p><p>在计算机编程社区中,code smell代表了任何标志着事物变坏的征兆。它常常标志代码应该被refactored或者全部的设计都应该被reviewed。这个短语出现在 WardsWiki上，它是被Kent Beck杜撰出来的。在refactoring兴起之后，这个短语的使用率骤增。</p><p>判断是否存在code smell经常是主观判断，并且随着语言、开发者、开发理论的不同而存在差异。</p><p>经验丰富和知识渊博的开发人员通过对优秀设计有一种“感觉”，他们已经达到一种称之为“无意识能力 （UnconsciousCompetence）”的状态。也就是说，他们无需思考，只要通过查看代码或一段设计就可以立马对这个项目的代码质量有一种 “感觉”，能够对代码设计的优劣有一个大致的判断。</p><p>但大家需要注意，code smell只是一种“暗示”，而非一种“确定”。将某些事物称之为“code smell”并未是一种攻击；它只是一种提示：开发人员需要对项目设计进行更进一步的查看。因此，code smell更多是“直觉的，本能的”。</p></li><li><p>Anti-pattern </p><p>反模式：告诉你在开发、设计、管理中不要采用的糟糕的解决方案。<br>与优秀的改进型模式相反，反模式告诉我们避免这些糟糕的模式采用优秀的模式。</p><p>主要有这些反模式：</p><ul><li>Organizational anti-patterns</li><li>Project management anti-patterns</li><li>Analysis anti-patterns</li><li>Software design anti-patterns（Object-oriented design anti-patterns）</li><li>Programming anti-patterns</li><li>Methodological anti-patterns</li><li>Configuration management anti-patterns</li></ul></li></ul><h2 id="利用深度学习进行代码异味检测"><a href="#利用深度学习进行代码异味检测" class="headerlink" title="利用深度学习进行代码异味检测"></a>利用深度学习进行代码异味检测</h2><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><p><a href="https://arxiv.org/pdf/1910.07658.pdf" target="_blank" rel="noopener">Deep Learning Anti-patterns from Code Metrics History</a></p><p>使用卷积神经网络(CNN)捕获修订历史(revision history)中的结构代码变更。</p><p><img src="/2019/12/11/Mining-Software-Repositories-in-the-age-of-AI/image-1.png" alt="image-1"></p><p>关于源代码的历史信息的改变极大地提高了检测性能。</p><p><img src="/2019/12/11/Mining-Software-Repositories-in-the-age-of-AI/image-2.png" alt="image-2"></p><p>CNN的表现也优于传统的ML模型。</p><p><img src="/2019/12/11/Mining-Software-Repositories-in-the-age-of-AI/image-3.png" alt="image-3"></p><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p><a href="https://arxiv.org/pdf/1712.09835.pdf" target="_blank" rel="noopener">Connecting Software Metrics across Versions to Predict Defects</a></p><p>利用递归神经网络(RNN)捕获度量变化序列（sequences of metrics changes）</p><p><img src="/2019/12/11/Mining-Software-Repositories-in-the-age-of-AI/image-4.png" alt="image-4"></p><p><strong>HVSM</strong>: Historical Version Sequence of Metrics</p><p>(a) constructing the historical version sequence of each file in our projects</p><p>(b) extracting the HVSM of each file from its version sequence</p><p>(c) leveraging RNN to predict file-level defects using the extracted HVSMs</p><p><img src="/2019/12/11/Mining-Software-Repositories-in-the-age-of-AI/image-5.png" alt="image-5"></p><p>与使用代码和过程度量的典型技术相比，使用HVSM的RNN具有更好的性能。</p><p>基于RNN的模型在不同的场景下都能优于基线分类器。</p><p><img src="/2019/12/11/Mining-Software-Repositories-in-the-age-of-AI/image-6.png" alt="image-6"></p>]]></content>
    
    <summary type="html">
    
      对Mining Software Repositories in the age of AI报告的记录与总结
    
    </summary>
    
    
      <category term="NASAC2019" scheme="http://yoursite.com/categories/NASAC2019/"/>
    
      <category term="软件仓库挖掘论坛" scheme="http://yoursite.com/categories/NASAC2019/%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93%E6%8C%96%E6%8E%98%E8%AE%BA%E5%9D%9B/"/>
    
    
      <category term="NASAC2019" scheme="http://yoursite.com/tags/NASAC2019/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/12/10/hello-world/"/>
    <id>http://yoursite.com/2019/12/10/hello-world/</id>
    <published>2019-12-10T02:02:14.794Z</published>
    <updated>2019-12-11T08:07:03.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人博客的第一篇文章"><a href="#个人博客的第一篇文章" class="headerlink" title="个人博客的第一篇文章"></a>个人博客的第一篇文章</h1><p>​        经过了两天的搭建，终于有了自己个人博客的雏形，基本符合自己的审美。</p><p>​        之前在CSDN的博客也是在学软件构造的时候老师强迫着写的，主要就是学习笔记。如今有了个人博客，不能浪费这么漂亮的页面，就像美丽的花园没有鲜花点缀一样。明年六月份就要毕业了，九月份就要研究生入学了，得勤快一点多学一点东西多记录一点东西，不然毕业啥都不会可咋整。</p><p>​        最后以最近看到的一句话收尾，“有险在前，唯刚健而不陷，方可涉大川。”</p>]]></content>
    
    <summary type="html">
    
      一些废话
    
    </summary>
    
    
    
  </entry>
  
</feed>
